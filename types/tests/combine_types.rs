use std::collections::BTreeSet;
use std::ffi::OsStr;
use std::fs::{read_dir, remove_file, DirEntry, File};
use std::io::BufRead;
use std::io::BufReader;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::{Command, ExitStatus};

const OUTPUT_DIR: &str = "./bindings";
const OUTPUT_FILE: &str = "index.d.ts";

/// Returns whether a line should be copied to the output.
///
/// A line should be copied to the output if it is not empty and isn't an `import` statement.
fn should_include(line: &str) -> bool {
	!line.is_empty() && !line.starts_with("import")
}

/// Examines `dir_entry` and returns `true` if its contents should be included in the combined
/// output file. Returns `false` otherwise.
fn should_consider_entry(dir_entry: &DirEntry) -> bool {
	let metadata = dir_entry.metadata().ok();

	// If we have metadata, we can consider it.
	if let Some(metadata) = metadata {
		if metadata.is_symlink() || metadata.is_dir() {
			// If the metadata indicates this file is a symlink or a directory, ignore it.
			false
		} else {
			// Otherwise, consider the file's pathname.
			let path = dir_entry.path();

			// Verify that the file is a .ts file _other_ than the output file.
			path.extension() == Some(OsStr::new("ts"))
				&& path.file_name() != Some(OsStr::new(&OUTPUT_FILE))
		}
	} else {
		// If we don't have metadata, ignore the file.
		false
	}
}

/// Returns an iterator over the relevant entries of `dir`.
fn find_relevant_sources(dir: &str) -> Result<impl Iterator<Item = PathBuf>, std::io::Error> {
	Ok(
		read_dir(dir)?
			.into_iter()
			.filter_map(Result::ok)
			.filter(should_consider_entry)
			.map(|dir_entry| dir_entry.path()),
	)
}

/// Runs `npx prettier --write` on `path` and returns the `ExitStatus` of the underlying command.
fn run_prettier(path: &Path) -> ExitStatus {
	Command::new("npx")
		.arg("prettier")
		.arg("--write")
		.arg(path.as_os_str())
		.status()
		.expect("failed to determine exit status")
}

const TSCODE_PREAMBLE: [&str; 5] = [
	"/* tslint:disable */",
	"",
	"/* WARNING: This file is automatically generated */",
	"/* DO NOT CHANGE IT MANUALLY */",
	"",
];

/// Generates unprettified output from the set of input files.
fn generate_tscode(paths: &BTreeSet<PathBuf>) -> Result<String, std::io::Error> {
	let mut output = String::new();

	// First, set the preamble.
	for line in TSCODE_PREAMBLE {
		output.push_str(line);
		output.push('\n');
	}

	// For each path, open and read the file, appending lines to be included to `output`.
	for path in paths {
		let file = File::open(&path)?;
		let reader = BufReader::new(file);

		for line in reader
			.lines()
			.flatten()
			.filter(|line| should_include(line.as_str()))
		{
			output.push_str(&line);
			output.push_str("\n\n");
		}
	}

	Ok(output)
}

/// Generate an output filename by combining `dirname` and `filename`.
fn output_file(dirname: &str, filename: &str) -> PathBuf {
	let mut output_file = PathBuf::from(dirname);
	output_file.push(filename);
	output_file
}

#[test]
fn create_index() -> Result<(), std::io::Error> {
	let output_file = output_file(OUTPUT_DIR, OUTPUT_FILE);

	let paths: BTreeSet<_> = find_relevant_sources(OUTPUT_DIR)?.collect();

	let tscode = generate_tscode(&paths)?;

	for path in paths {
		remove_file(path)?;
	}

	{
		let mut tsfile = File::create(output_file.as_path())?;
		tsfile.write_all(tscode.as_bytes())?;
	}

	run_prettier(output_file.as_path());

	Ok(())
}
