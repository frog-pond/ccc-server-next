use std::collections::BTreeSet;
use std::ffi::OsStr;
use std::fs::{read_dir, remove_file, DirEntry, File};
use std::io::BufRead;
use std::io::BufReader;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::{Command, ExitStatus};

const OUTPUT_DIR: &str = "./bindings";
const OUTPUT_FILE: &str = "index.d.ts";

fn should_include(line: &str) -> bool {
	!line.is_empty() && !line.starts_with("import")
}

/// Examines `dir_entry` and returns `true` if its contents should be included in the combined
/// output file. Returns `false` otherwise.
fn should_consider_entry(dir_entry: &DirEntry) -> bool {
	let metadata = dir_entry.metadata().ok();

	// If we have metadata, we can consider it.
	if let Some(metadata) = metadata {
		if metadata.is_symlink() || metadata.is_dir() {
			// If the metadata indicates this file is a symlink or a directory, ignore it.
			false
		} else {
			// Otherwise, consider the file's pathname.
			let path = dir_entry.path();

			// Verify that the file is a .ts file _other_ than the output file.
			path.extension() == Some(OsStr::new("ts"))
				&& path.file_name() != Some(OsStr::new(&OUTPUT_FILE))
		}
	} else {
		// If we don't have metadata, ignore the file.
		false
	}
}

fn find_relevant_sources(
	dir: &str,
) -> Result<impl Iterator<Item = PathBuf>, Box<dyn std::error::Error>> {
	Ok(
		read_dir(dir)?
			.into_iter()
			.filter_map(Result::ok)
			.filter(should_consider_entry)
			.map(|dir_entry| dir_entry.path()),
	)
}

fn run_prettier(path: &Path) -> ExitStatus {
	Command::new("npx")
		.arg("prettier")
		.arg("--write")
		.arg(path.as_os_str())
		.status()
		.expect("failed to determine exit status")
}

#[test]
fn create_index() -> Result<(), Box<dyn std::error::Error>> {
	let mut tsfile = File::create(format!("{}/{}", OUTPUT_DIR, OUTPUT_FILE))?;
	let mut tscode = "".to_owned();

	tscode.push_str(
		"/* tslint:disable */\n\n\
        /* WARNING: This file is automatically generated */\n\
        /* DO NOT CHANGE IT MANUALLY */\n\n",
	);

	let paths: BTreeSet<_> = find_relevant_sources(OUTPUT_DIR)?.collect();

	for path in paths {
		let file = File::open(&path)?;
		let reader = BufReader::new(file);

		for line in reader
			.lines()
			.flatten()
			.filter(|line| should_include(line.as_str()))
		{
			tscode.push_str(&line);
			tscode.push('\n');
		}

		remove_file(path)?;
	}

	Ok(tsfile.write_all(tscode.as_bytes())?)
}
