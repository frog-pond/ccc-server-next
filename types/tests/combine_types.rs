use std::collections::BTreeSet;
use std::ffi::OsStr;
use std::fs::{read_dir, remove_file, File};
use std::io::BufRead;
use std::io::BufReader;
use std::io::Write;
use std::path::Path;

const OUTPUT_DIR: &str = "./bindings";
const OUTPUT_FILE: &str = "index.d.ts";

fn line_should_be_included_in_output(line: &&str) -> bool {
	!line.is_empty() && !line.starts_with("import")
}

#[test]
fn create_index() -> Result<(), Box<dyn std::error::Error>> {
	let mut tsfile = File::create(format!("{}/{}", OUTPUT_DIR, OUTPUT_FILE))?;
	let mut tscode = "".to_owned();

	tscode.push_str(
		"/* tslint:disable */\n\n\
        /* WARNING: This file is automatically generated */\n\
        /* DO NOT CHANGE IT MANUALLY */\n\n",
	);

	let ts_ext = OsStr::new("ts");
	let output_file = OsStr::new(&OUTPUT_FILE);

	let paths: BTreeSet<_> = read_dir(OUTPUT_DIR)?
		.into_iter()
		.filter_map(std::result::Result::ok)
		.map(|r| r.path())
		.filter(|r| r.extension() == Some(ts_ext))
		.filter(|r| r.file_name() != Some(output_file))
		.collect();

	for entry in paths {
		for line in BufReader::new(File::open(&entry)?).lines().flatten() {
			if line_should_be_included_in_output(&line.as_str()) {
				tscode.push_str(&line);
				tscode.push('\n');
			}
		}

		remove_file(Path::new(&entry))?;
	}

	Ok(tsfile.write_all(tscode.as_bytes())?)
}
